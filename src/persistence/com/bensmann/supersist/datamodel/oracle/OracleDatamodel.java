/*
 * OracleDatamodel.java
 *
 * Created on 7. Mai 2006, 11:15
 *
 */

package com.bensmann.supersist.datamodel.oracle;

import com.bensmann.superframe.java.lang.ClassUtil;
import com.bensmann.superframe.xml.JAXPOutput;
import com.bensmann.supersist.datamodel.inspector.impl.AbstractInspector;
import com.bensmann.supersist.datamodel.transfer.DatamodelTransferObject;
import com.bensmann.supersist.datamodel.MyBean;
import com.bensmann.supersist.datamodel.inspector.InspectorDocument;
import com.bensmann.supersist.exception.DatamodelException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 *
 * @author rb
 * @version 1.0
 */
public final class OracleDatamodel extends AbstractInspector {
    
    /**
     * Inspector XML document
     */
    private InspectorDocument inspectorDocument;
    
    /**
     * XML document generated by Inspector
     */
    private Document document;
    
    /**
     * Cache for connection/data model
     */
    private static Map<Connection, OracleDatamodel> cache;
    
    /**
     *
     */
    static {
        cache = new Hashtable<Connection, OracleDatamodel>();
    }
    
    /**
     * Creates a new instance of OracleDatamodel
     *
     * @param connection A JDBC connection object
     */
    private OracleDatamodel(Connection connection) {
        
        this.setConnection(connection);
        
        try {
            refreshDatamodel();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        }
        
    }
    
    /**
     *
     * @param connection
     * @return
     */
    public static OracleDatamodel getInstance(Connection connection) {
        
        OracleDatamodel instance = null;
        
        // Lookup instance in cache
        instance = cache.get(connection);
        
        // If no instance was found, create one and put it into the cache
        if (instance == null) {
            instance = new OracleDatamodel(connection);
            cache.put(connection, instance);
        } else {
            logger.config(
                    "Using cached OracleDatamodel instance for " + connection);
        }
        
        return instance;
        
    }
    
    /**
     * Determines Java type that should be used with certain type, length,
     * precision and scale.
     *
     * @deprecated Use getJavaTypeId()
     * @param dataType
     * @param dataLength
     * @param dataPrecision
     * @param dataScale
     * @return
     */
    private String getJavaTypeName(String dataType, int dataLength,
            int dataPrecision, int dataScale) {
        
        String javaType = null;
        
        // Determine Java type corresponding to SQL data-type
        if (dataType.indexOf("CHAR") >= 0) {
            
            if (dataLength == 1) {
                javaType = "java.lang.Character";
            } else {
                javaType = "java.lang.String";
            }
            
        } else if (dataType.equals("DATE")) {
            javaType = "java.util.Date";
        } else if (dataType.equals("NUMBER")) {
            javaType = "java.lang.BigDecimal";
        } else {
            javaType = "java.lang.Object";
        }
        
        return javaType;
        
    }
    
    /**
     *
     * @param dataType
     * @param dataLength
     * @param dataPrecision
     * @param dataScale
     * @return
     */
    private int getJavaTypeId(String dataType, int dataLength,
            int dataPrecision, int dataScale) {
        
        int type = -1;
        
        if (dataType.equals("CHAR")) {
            type = Types.CHAR;
        } else if (dataType.equals("VARCHAR")) {
            type = Types.VARCHAR;
        } else if (dataType.equals("NUMBER")) {
            type = Types.BIGINT;
        }
        
        return type;
        
    }
    
    /**
     *
     *
     * @return
     * @param dataLength
     * @param dataType
     */
    private int correctLength(String dataType, int dataLength) {
        
        // Length of VARCHAR in Oracle is 255, VARCHAR2 has a maximum of
        // 4000 characters
        if (dataType.equals("VARCHAR") && dataLength == -1) {
            dataLength = 255;
        } else if (dataType.equals("VARCHAR2") && dataLength == -1) {
            dataLength = 4000;
        }
        
        return dataLength;
        
    }
    
    /**
     *
     *
     * @return
     * @param dataType
     * @param dataPrecision
     */
    private int correctPrecision(String dataType, int dataPrecision) {
        
        // NUMBER in Oracle is reported with 22 bytes of length and
        // unknown precision and scale, but it's 38 and 0
        if (dataType.equals("NUMBER") && dataPrecision == 0) {
            dataPrecision = 38;
        }
        
        return dataPrecision;
        
    }
    
    /**
     *
     *
     * @return
     * @param dataType
     * @param dataScale
     */
    private int correctScale(String dataType, int dataScale) {
        
        // NUMBER in Oracle is reported with 22 bytes of length and
        // unknown precision and scale, but it's 38 and 0
        if (dataType.equals("NUMBER") && dataScale == -1) {
            dataScale = 0;
        }
        
        return dataScale;
        
    }
    
    /**
     * Read information about tables and views and store them into
     * datamodel XML document
     *
     * @throws com.bensmann.supersist.exception.DatamodelException
     */
    public void inspectTablesAndViews() throws DatamodelException {
        
        Element tablesElement = document.createElement("tables");
        Element tableElement = null;
        Element columnElement = null;
        Statement dataDictionaryStatement = null;
        ResultSet dataDictionaryResultSet = null;
        String metaDataQuery = null;
        String allTables =
                "SELECT 'table' type, t.table_name, c.column_name," +
                " c.data_type, c.data_length, c.data_precision, c.data_scale," +
                " c.nullable" +
                "  FROM user_tables t, user_tab_columns c" +
                " WHERE t.table_name = c.table_name" +
                " UNION " +
                "SELECT 'view' type, v.view_name, c.column_name," +
                " c.data_type, c.data_length, c.data_precision, c.data_scale," +
                " c.nullable" +
                "  FROM user_views v, user_tab_columns c" +
                " WHERE v.view_name = c.table_name";
        String actualTableName = null;
        String tmp = "";
        String type = null;
        String tmpType = null;
        String columnName = null;
        Map<String, String[]> metaDataMap = new Hashtable<String, String[]>();
        String[] columnMetaData = null;
        String data_type = null;
        int data_length = 0;
        int data_precision = 0;
        int data_scale = 0;
        String nullable = null;
        int rowLength = 0;
        int allTablesRowLength = 0;
        int tableCount = 0;
        int viewCount = 0;
        int columnCount = 0;
        Integer tmpInteger = null;
        
        // TODO Following try/catch-blocks depend on each other!
        
        try {
            dataDictionaryStatement = getConnection().createStatement();
        } catch (SQLException e) {
            throw new DatamodelException(
                    "Cannot create statement object: " + e.getMessage(), e);
        }
        
        try {
            dataDictionaryResultSet =
                    dataDictionaryStatement.executeQuery(allTables);
        } catch (SQLException e) {
            throw new DatamodelException(
                    "Cannot query table and view information: "
                    + e.getMessage(), e);
        }
        
        // Add tables-element to root
        rootElement.appendChild(tablesElement);
        
        try {
            
            while (dataDictionaryResultSet.next()) {
                
                actualTableName = dataDictionaryResultSet.getString("table_name");
                // Type to determine wheter we have a table or view
                type = dataDictionaryResultSet.getString("type");
                // Column metadata
                columnName = dataDictionaryResultSet.getString("column_name");
                data_type = dataDictionaryResultSet.getString("data_type");
                data_length = dataDictionaryResultSet.getInt("data_length");
                data_precision =
                        dataDictionaryResultSet.getInt("data_precision");
                data_scale = dataDictionaryResultSet.getInt("data_scale");
                nullable = dataDictionaryResultSet.getString("nullable");
                
                // Correct length, precision and scale values
                data_length = correctLength(data_type, data_length);
                data_precision = correctPrecision(data_type, data_precision);
                data_scale = correctScale(data_type, data_scale);
                // Check nullable
                if (nullable.equals("Y")) {
                    nullable = "yes";
                } else {
                    nullable = "no";
                }
                
                // Count row length of tables
                if (data_length > 0) {
                    
                    rowLength += data_length;
                    
                    if (type.equals("table")) {
                        allTablesRowLength += rowLength;
                    }
                    
                }
                
                // A new table/view?
                if (!actualTableName.equals(tmp)) {
                    
                    // Add statistics (only if a tableElement exists; for first run)
                    if (tableElement != null && tablesElement != null) {
                        
                        tableElement.setAttribute(
                                "column-count", "" + columnCount);
                        tableElement.setAttribute(
                                "maximum-row-length", "" + rowLength);
                        
                        //
                        if (tmpType != null && tmpType.equals("table")) {
                            tableElement.appendChild(getReadCountElement(rowLength));
                        }
                        
                        // Set column-count attribute
                        tablesElement.appendChild(tableElement);
                        
                    }
                    
                    // Create new table element
                    tableElement = document.createElement(type);
                    tableElement.setAttribute("name", actualTableName);
                    
                    // Get metadata for table columns
                    metaDataMap = getMetaDataMap(actualTableName);
                    
                    // Reset counters
                    rowLength = 0;
                    columnCount = 0;
                    if (tmpType != null) {
                        if (tmpType.equals("table")) {
                            tableCount++;
                        } else if (tmpType.equals("view")) {
                            viewCount++;
                        }
                    }
                    
                }
                
                tmp = actualTableName;
                tmpType = type;
                columnMetaData = metaDataMap.get(columnName);
                
                columnElement = document.createElement("column");
                columnElement.setAttribute("name", columnName);
                if (columnMetaData != null) {
                    columnElement.setAttribute("java-type", columnMetaData[0]);
                    columnElement.setAttribute("java-type-id", columnMetaData[1]);
                }
                columnElement.setAttribute("data-type", data_type);
                columnElement.setAttribute("data-length", "" + data_length);
                columnElement.setAttribute("data-precision", "" + data_precision);
                columnElement.setAttribute("data-scale", "" + data_scale);
                columnElement.setAttribute("nullable", nullable);
                tableElement.appendChild(columnElement);
                
                // Increase column counters
                columnCount++;
                
            }
            
        } catch (SQLException e) {
            throw new DatamodelException(
                    "Cannot process result set: " + e.getMessage(), e);
        }
        
        // Set attribute table count
        tablesElement.setAttribute("table-count", "" + tableCount);
        // Set attribute view count
        tablesElement.setAttribute("view-count", "" + viewCount);
        // Set attribute maximum row length of all tables
        tablesElement.setAttribute("maximum-row-length",
                "" + allTablesRowLength);
        //
        tablesElement.appendChild(getReadCountElement(allTablesRowLength));
        
        // Close result set and statement objects
        try {
            dataDictionaryResultSet.close();
            dataDictionaryStatement.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        
    }
    
    /**
     * Read information about packages and stored procedures and their
     * arguments and store them into datamodel XML document
     *
     * @throws com.bensmann.supersist.exception.DatamodelException
     */
    public void inspectProceduresAndFunctions() throws DatamodelException {
        
        Element proceduresElement = null;
        Element procedureElement = null;
        Element argumentElement = null;
        String allArguments =
                "SELECT a.package_name, p.procedure_name," +
                " a.argument_name, a.position, a.data_type," +
                " a.data_length, a.data_precision, a.data_scale," +
                " a.in_out" +
                "  FROM user_procedures p, user_arguments a" +
                " WHERE p.procedure_name = a.object_name" +
                " ORDER BY a.package_name, p.procedure_name";
        Statement statement = null;
        ResultSet resultSet = null;
        ResultSetMetaData resultSetMetaData = null;
        Map<String, Integer> javaTypeMap = null;
        String actualProcedureName = null;
        String tmp = "";
        String type = null;
        String argumentType = null;
        String argument_name = null;
        int position = 0;
        String data_type = null;
        int data_length = 0;
        int data_precision = 0;
        int data_scale = 0;
        String in_out = null;
        String javaType = null;
        int argumentCount = 0;
        int procedureCount = 0;
        int functionCount = 0;
        
        // Add procedures-element to root
        proceduresElement = document.createElement("procedures");
        rootElement.appendChild(proceduresElement);
        
        // TODO Following try/catch-blocks depend on each other!
        
        // Execute SQL statement and retrieve result set and meta data
        try {
            statement = getConnection().createStatement();
        } catch (SQLException e) {
            throw new DatamodelException(
                    "Cannot create statement object: " + e.getMessage(), e);
        }
        
        try {
            resultSet = statement.executeQuery(allArguments);
            resultSetMetaData = resultSet.getMetaData();
        } catch (SQLException e) {
            throw new DatamodelException(
                    "Cannot query procedure and function information: "
                    + e.getMessage(), e);
        }
        
        try {
            
            // Lookup Java data types for every column
            javaTypeMap = new HashMap<String, Integer>();
            for (int i = 1; i < resultSetMetaData.getColumnCount(); i++) {
                javaTypeMap.put(
                        resultSetMetaData.getColumnName(i),
                        resultSetMetaData.getColumnType(i));
            }
            
        } catch (SQLException e) {
            throw new DatamodelException(
                    "Cannot get Java type information for columns: "
                    + e.getMessage(), e);
        }
        
        try {
            
            //
            while (resultSet.next()) {
                
                actualProcedureName = resultSet.getString("procedure_name");
                // TODO argument_name == null
                argument_name = resultSet.getString("argument_name");
                position = resultSet.getInt("position");
                // TODO data_type == null
                data_type = resultSet.getString("data_type");
                data_length = resultSet.getInt("data_length");
                data_precision = resultSet.getInt("data_precision");
                data_scale = resultSet.getInt("data_scale");
                in_out = resultSet.getString("in_out");
                
                if (argument_name != null) {
                    javaType = getJavaTypeName(
                            data_type, data_length, data_precision, data_scale);
                }
                
                // Check argument name and position; if name is null and
                // position == 0 then it's a function
                if (argument_name == null && position == 0) {
                    type = "function";
                    argumentType = "return-value";
                    argument_name = "";
                } else {
                    type = "procedure";
                    argumentType = "argument";
                }
                
                // Correct precision and scale values
                if (data_type != null) {
                    data_length = correctLength(data_type, data_length);
                    data_precision = correctPrecision(data_type, data_precision);
                    data_scale = correctScale(data_type, data_scale);
                }
                
                // If actual procedure/function name is different from
                // the last one (tmp) then it's a new procedure/function
                if (!actualProcedureName.equals(tmp)) {
                    
                    if (procedureElement != null && proceduresElement != null) {
                        // Add argument-count attribute
                        procedureElement.setAttribute(
                                "argument-count", "" + argumentCount);
                        proceduresElement.appendChild(procedureElement);
                    }
                    
                    procedureElement = document.createElement(type);
                    procedureElement.setAttribute("name", actualProcedureName);
                    procedureElement.setAttribute("package-name",
                            resultSet.getString("package_name"));
                    
                    argumentCount = 0;
                    if (type.equals("procedure")) {
                        procedureCount++;
                    } else if (type.equals("function")) {
                        functionCount++;
                    }
                    
                }
                
                // Assign actual procedure name to tmp for comparing it
                // in the next loop
                tmp = actualProcedureName;
                
                argumentElement = document.createElement(argumentType);
                // Only arguments have a name and position and can be IN or OUT
                // arguments
                // TODO: BUG? If name+position+in-out are in the if, no functions are found in XML???
//            if (argumentType.equals("argument")) {
                argumentElement.setAttribute("name", argument_name);
//            }
                argumentElement.setAttribute("position", "" + position);
                argumentElement.setAttribute("in-out", in_out);
                argumentElement.setAttribute("java-type", javaType);
                argumentElement.setAttribute("data-type", data_type);
                argumentElement.setAttribute("data-length", "" + data_length);
                argumentElement.setAttribute("data-precision", "" + data_precision);
                argumentElement.setAttribute("data-scale", "" + data_scale);
                procedureElement.appendChild(argumentElement);
                
                // Increase argument counter if it's not a return-value
                if (argumentType.equals("argument")) {
                    argumentCount++;
                }
                
            }
            
        } catch (SQLException e) {
            throw new DatamodelException(
                    "Cannot process result set: " + e.getMessage(), e);
        }
        
        proceduresElement.setAttribute("procedure-count", ""+ procedureCount);
        proceduresElement.setAttribute("function-count", "" + functionCount);
        
        // Close result set and statement objects
        try {
            resultSet.close();
            statement.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        
    }
    
    /**
     * Creates a name for a method for a certain column or argument name.
     * Used with Java Reflection API for communication with
     * DatamodelTransferObject/Java Beans.
     *
     * @param name Column or argument name
     * @return
     */
    private String getMethodNameForColumnOrArgument(String name) {
        
        StringBuffer tmp = new StringBuffer(name);
        int i = 0;
        char d = '\0';
        
        // Replace Oracle prefixes
        i = tmp.indexOf("P_");
        if (i == 0) {
            tmp.replace(0, 2, "");
        }
        i = tmp.indexOf("V_");
        if (i == 0) {
            tmp.replace(0, 2, "");
        }
        
        // First character must be upper case and the rest lower case
        for (i = 0; i < tmp.length(); i++) {
            
            if (i == 0) {
                d = Character.toUpperCase(tmp.charAt(i));
            } else {
                d = Character.toLowerCase(tmp.charAt(i));
            }
            
            tmp.setCharAt(i, d);
            
        }
        
        return tmp.toString();
        
    }
    
    /**
     * Lookup a method by a column or argument name and ignore case
     */
    private Method lookupMethodForColumnOrArgument(Class clazz, String name) {
        return ClassUtil.findMethodByName(clazz, name, true);
    }
    
    /**
     *
     * @param callableStatement
     * @param argumentPosition
     * @param argumentDataType
     * @param argumentDataLength
     * @param argumentDataPrecision
     * @param argumentDataScale
     * @param value
     * @throws com.bensmann.superframe.exceptions.DatamodelException
     */
    public void setCallableStatementArgument(
            CallableStatement callableStatement, int argumentPosition,
            String argumentDataType, int argumentDataLength,
            int argumentDataPrecision, int argumentDataScale,
            Object value)
            throws DatamodelException {
        
//        System.out.println(
//                " argumentDataType=" + argumentDataType +
//                " argumentLength=" + argumentDataLength +
//                " argumentPrecision=" + argumentDataPrecision +
//                " argumentScale=" + argumentDataScale +
//                " value=" + value);
        
        // TODO: Use setObject()
        
        try {
            
            if (argumentDataType.indexOf("CHAR") >= 0) {
                
                callableStatement.
                        setString(argumentPosition, (String) value);
                
            } else if (argumentDataType.equals("NUMBER")) {
                
                if (argumentDataScale == 0) {
                    
                    if (argumentDataPrecision <= 10) {
                        
                        callableStatement.setInt(argumentPosition,
                                Integer.valueOf("" + value));
                        
                    } else {
                        
                        callableStatement.setLong(argumentPosition,
                                Long.valueOf("" + value));
                        
                    }
                    
                } else {
                    
                    callableStatement.setDouble(argumentPosition,
                            Double.valueOf("" + value));
                    
                }
                
            } else if (argumentDataType.equals("DATE")) {
                
                callableStatement.setDate(argumentPosition,
                        new java.sql.Date(
                        ((java.util.Date) value).getTime()));
                
            }
            
        } catch (SQLException e) {
            throw new DatamodelException("", e);
        }
        
    }
    
    /**
     *
     * @throws com.bensmann.supersist.exception.DatamodelException
     */
    public void generateDatamodelTransferObjects() throws DatamodelException {
        
    }
    
    /**
     * Retrieves all neccessary data from a Java bean and executes a stored
     * procedure.
     *
     * @param bean
     * @param packageName
     * @param procedureName
     * @throws com.bensmann.superframe.exceptions.DatamodelException
     */
    public void applyTransferObjectToProcedure(Object bean, String packageName,
            String procedureName)
            throws DatamodelException {
        
        CallableStatement callableStatement = null;
        String[] argumentNames = null;
        String argumentName = null;
        String argumentDataType = null;
        int argumentDataLength = 0;
        int argumentDataPrecision = 0;
        int argumentDataScale = 0;
        int argumentPosition = 0;
        String argumentParameterType = null;
        int type = 0;
        Types argumentJavaSqlType = null;
        String methodName = null;
        Class[] emptyClassArray = new Class[] {};
        Object[] emptyObjectArray = new Object[] {};
        Method method = null;
        Object value = null;
        
        // Get callable statement for stored procedure
        callableStatement = getCallableStatement(packageName, procedureName);
        
        // Get arguments for stored procedure
        argumentNames = getArgumentNames(packageName, procedureName);
        
        // For every argument get data from the bean and give it to the
        // callable statement
        for (int i = 0; i < argumentNames.length; i++) {
            
            // Get argument name, its type and its position in the callable
            // statement
            argumentName = argumentNames[i];
            argumentDataType =
                    getArgumentDataType(packageName, procedureName,
                    argumentName);
            argumentDataLength =
                    getArgumentDataLength(packageName, procedureName,
                    argumentName);
            argumentDataPrecision =
                    getArgumentDataPrecision(packageName, procedureName,
                    argumentName);
            argumentDataScale =
                    getArgumentDataScale(packageName, procedureName,
                    argumentName);
            argumentPosition =
                    getArgumentPosition(packageName, procedureName,
                    argumentName);
            argumentParameterType =
                    getArgumentParameterType(packageName, procedureName,
                    argumentName);
            
            type = getJavaTypeId(
                    argumentDataType, argumentDataLength,
                    argumentDataPrecision, argumentDataScale);
            
            // IN/OUT-parameters:
            if (argumentParameterType.equals("IN")) {
                
                methodName = "get" +
                        getMethodNameForColumnOrArgument(argumentName);
                
                // Call methodName on bean and set value in callable statement
                try {
                    
                    method = bean.getClass().getMethod(
                            methodName, emptyClassArray);
                    value = method.invoke(bean, emptyObjectArray);
                    
                    if (value == null) {
                        callableStatement.setNull(argumentPosition, type);
                    } else {
                        
                        setCallableStatementArgument(callableStatement,
                                argumentPosition, argumentDataType,
                                argumentDataLength, argumentDataPrecision,
                                argumentDataScale, value);
                        
                    }
                    
                } catch (SecurityException e) {
                    throw new DatamodelException("", e);
                } catch (NoSuchMethodException e) {
                    //throw new DatamodelException("", e);
                    logger.warning("Cannot access: " + methodName);
                } catch (IllegalAccessException e) {
                    throw new DatamodelException("", e);
                } catch (InvocationTargetException e) {
                    throw new DatamodelException("", e);
                } catch (SQLException e) {
                    throw new DatamodelException(
                            "Cannot apply data from bean to " +
                            "stored procedure: " + e.getMessage(), e);
                }
                
            }
            // An OUT-parameter must be registered with the callable statement
            // and later set the value in the bean using a setter-method
            else if (argumentParameterType.equals("OUT")) {
                
                try {
                    
                    callableStatement.
                            registerOutParameter(argumentPosition, type);
                    
                } catch (SQLException e) {
                    throw new DatamodelException("", e);
                }
                
            }
            
        }
        
        // Execute callable statement
        try {
            callableStatement.executeUpdate();
        } catch (SQLException e) {
            throw new DatamodelException("Cannot execute stored procedure: " +
                    e.getMessage(), e);
        }
        
        // Set OUT-parameters in bean
        for (int i = 0; i < argumentNames.length; i++) {
            
            // Get argument name, its type and its position in the callable
            // statement
            argumentName = argumentNames[i];
            argumentDataType =
                    getArgumentDataType(packageName, procedureName,
                    argumentName);
            argumentDataLength =
                    getArgumentDataLength(packageName, procedureName,
                    argumentName);
            argumentDataPrecision =
                    getArgumentDataPrecision(packageName, procedureName,
                    argumentName);
            argumentDataScale =
                    getArgumentDataScale(packageName, procedureName,
                    argumentName);
            argumentPosition =
                    getArgumentPosition(packageName, procedureName,
                    argumentName);
            argumentParameterType =
                    getArgumentParameterType(packageName, procedureName,
                    argumentName);
            
            type = getJavaTypeId(
                    argumentDataType, argumentDataLength,
                    argumentDataPrecision, argumentDataScale);
            
            if (argumentParameterType.equals("OUT")) {
                
                methodName = "set" +
                        getMethodNameForColumnOrArgument(argumentName);
                
                try {
                    
                    // TODO: Different types...
                    method = bean.getClass().getMethod(methodName,
                            new Class[] { Long.TYPE });
                    value = callableStatement.getObject(argumentPosition);
                    method.invoke(bean, new Object[] { (Long) value });
                    
                } catch (SecurityException e) {
                    throw new DatamodelException("", e);
                } catch (NoSuchMethodException e) {
                    throw new DatamodelException(
                            "Cannot access method " + methodName, e);
                } catch (IllegalAccessException e) {
                    throw new DatamodelException("", e);
                } catch (InvocationTargetException e) {
                    throw new DatamodelException("", e);
                } catch (SQLException e) {
                    throw new DatamodelException(
                            "Cannot apply data from stored procedure to " +
                            "bean: " + e.getMessage(), e);
                }
                
            }
            
        }
        
    }
    
    /**
     *
     *
     * @param tableOrView
     * @param datamodelBean
     * @param whereClause
     * @throws com.bensmann.superframe.exceptions.DatamodelException
     * @return
     */
    public DatamodelTransferObject[] selectIntoTransferObject(
            String tableOrView, DatamodelTransferObject datamodelBean, String whereClause)
            throws DatamodelException {
        
        int i = 0;
        //
        List<DatamodelTransferObject> datamodelBeans = new LinkedList<DatamodelTransferObject>();
//        DatamodelBean[] tmpDatamodelBeans = null;
        Object obj = null;
        Class clazz = null;
        Class[] emptyClassArray = new Class[] {};
        Class[] stringClassArray = new Class[] { String.class };
        Class[] longClassArray = new Class[] { Long.TYPE };
        Class[] dateClassArray = new Class[] { Date.class };
        //
        int modifier = 0;
        Field[] fields = null;
        String methodName = null;
        Method method = null;
        // Counter for bean properties
        int beanPropertyCount = 0;
        int beanPropertyWithValueCount = 0;
        // Field[] with properties that will be used in the WHERE-Clause
        Field[] beanWhereProperties = null;
        // Arrays holding every non-transient field from bean
        String[] beanPropertyNames = null;
        Object[] beanPropertyValues = null;
        Class[] beanPropertyTypes = null;
        // Query operator is used for = or LIKE queries
        String queryOperator = null;
        // WHERE-clause made up by values from the bean
        StringBuffer beanWhereClause = null;
        // Temporary where clause; used to tie beanWhereClause and
        // whereClause together
        StringBuffer tmpWhereClause = null;
        //
        ResultSet resultSet = null;
        ResultSetMetaData resultSetMetaData = null;
        int rowCount = 1;
        // Get column names for table/view
//        String[] columnNames = getColumnNames(tableOrView);
        String columnName = null;
        String columnType = null;
        // Helper for analysing types or values
        Class hClass = null;
        Date hDate = null;
        Object value = null;
        //
        PreparedStatement prepStatement = null;
        
        // Get class from DatamodelBean
        clazz = datamodelBean.getClass();
        
        // Get a list of all non-transient fields (and their values)
        // from the bean
        fields = clazz.getDeclaredFields();
        beanPropertyNames = new String[fields.length];
        beanPropertyValues = new Object[fields.length];
        beanPropertyTypes = new Class[fields.length];
        for (Field field : fields) {
            
            modifier = field.getModifiers();
            
            // Check if field is not transient and if it is a column
            // in the table/view
            if (!Modifier.isTransient(modifier) &&
                    columnExists(tableOrView, field.getName())) {
                
                beanPropertyNames[beanPropertyCount] = field.getName();
                beanPropertyTypes[beanPropertyCount] = field.getType();
                beanPropertyValues[beanPropertyCount] =
                        ClassUtil.getFieldValue(field, datamodelBean);
                
                if (beanPropertyValues[beanPropertyCount] != null) {
                    beanPropertyWithValueCount++;
                }
                
//                System.out.println("bean " + field.getName() + "/" +
//                        beanPropertyNames[beanPropertyCount] + " = " +
//                        beanPropertyValues[beanPropertyCount] + " type= " +
//                        beanPropertyTypes[beanPropertyCount] +
//                        " withValueCount=" + beanPropertyWithValueCount);
                
                beanPropertyCount++;
                
            }
            
        }
        
        // All properties with a non-null value will be used in WHERE-clause
        // Build up Field[] for field with a value
        beanWhereProperties = new Field[beanPropertyWithValueCount];
        i = 0;
        for (Field field : fields) {
            
            modifier = field.getModifiers();
            
            if (!Modifier.isTransient(modifier) &&
                    columnExists(tableOrView, field.getName()) &&
                    ClassUtil.getFieldValue(field, datamodelBean) != null) {
                
                beanWhereProperties[i++] = field;
                
            }
            
        }
        
        // Build WHERE-clause based on values from the bean
        // Only include non-null values in the query
        beanWhereClause = new StringBuffer();
        for (Field field : beanWhereProperties) {
            
            // Standard query operator
            queryOperator = "=";
            
            // Need AND because there are conditions yet
            if (beanWhereClause.length() > 0) {
                beanWhereClause.append(" AND ");
            }
            
            // Check for wildcars/LIKE-query in String-values
            if (field.getType() == String.class) {
                
                value = (String) ClassUtil.getFieldValue(field, datamodelBean);
                
                if (((String) value).indexOf("%") >= 0) {
                    queryOperator = "LIKE";
                }
                
            }
            
            beanWhereClause.append(
                    field.getName() + " " + queryOperator + " ?");
            
        }
        
        // Create WHERE-clause
        if (beanWhereClause != null || whereClause != null) {
            tmpWhereClause = new StringBuffer();
        }
        if (beanWhereClause != null) {
            tmpWhereClause.append(beanWhereClause);
        }
        if (whereClause != null) {
            tmpWhereClause.append(" AND ").append(whereClause);
        }
        
        System.out.println("beanWhereClause: " + beanWhereClause.toString());
        System.out.println("where clause:" + tmpWhereClause.toString());
        
        // Set tmpWhereClause to null when no conditions exist
        if (tmpWhereClause.toString().length() == 0) {
            tmpWhereClause = null;
        }
        
        // Retrieve prepared statement for SELECT-query
        // TODO: For better optimization; which comes first:
        // beanWhereClause or whereClause? Are they AND- or OR-related?
        prepStatement = getPreparedSelectStatement(tableOrView,
                beanPropertyNames,
                tmpWhereClause != null ? tmpWhereClause.toString() : null);
        
        // Create DatamodelBean for every row from ResultSet and put it into
        // array datamodelBeans
        try {
            
            // Put non-null values from DatamodelBean into
            // prepared SELECT statement
            // Set values from bean properties in prepared statement
            i = 1;
            for (Field field : beanWhereProperties) {
                
                hClass = field.getType();
                value = ClassUtil.getFieldValue(field, datamodelBean);
                System.out.println(
                        "field type=" + hClass + "/" + hClass.getName()
                        + "/value=" + value);
                
                if (hClass == String.class) {
                    prepStatement.setString(i, (String) value);
                } else if (hClass == Long.TYPE || hClass == Long.class) {
                    prepStatement.setLong(i, (Long) value);
                } else if (hClass == Integer.TYPE || hClass == Integer.class) {
                    prepStatement.setInt(i, (Integer) value);
                } else if (hClass == Float.TYPE || hClass == Float.class) {
                    prepStatement.setFloat(i, (Float) value);
                }  else if (hClass == Double.TYPE || hClass == Double.class) {
                    prepStatement.setDouble(i, (Double) value);
                } else if (hClass == Date.class) {
                    hDate = (java.util.Date) value;
                    prepStatement.setDate(i, new java.sql.Date(hDate.getTime()));
                }
                
                i++;
                
            }
            
            // Exceute query
            resultSet = prepStatement.executeQuery();
            resultSetMetaData = resultSet.getMetaData();
            
            // Convert result set into array of DatamodelBeans
            while(resultSet.next()) {
                
                // Create DatamodelBean with data from row
                try {
                    
                    obj = clazz.newInstance();
                    
                    for (beanPropertyCount = 1;
                    beanPropertyCount < resultSetMetaData.getColumnCount() + 1;
                    beanPropertyCount++) {
                        
                        columnName = resultSetMetaData.
                                getColumnName(beanPropertyCount);
                        methodName = "set" +
                                getMethodNameForColumnOrArgument(columnName);
                        
                        columnType = getColumnType(tableOrView, columnName);
                        
                        try {
                            
                            if (columnType.startsWith("VARCHAR")) {
                                method = clazz.
                                        getMethod(methodName, stringClassArray);
                                method.invoke(
                                        obj, resultSet.getString(beanPropertyCount));
                            } else if (columnType.equals("NUMBER")) {
                                // TODO !!! int,long,float,double?
                                method = clazz.
                                        getMethod(methodName, longClassArray);
                                method.invoke(obj,
                                        resultSet.getLong(beanPropertyCount));
                            } else if (columnType.equals("DATE")) {
                                method = clazz.
                                        getMethod(methodName, dateClassArray);
                                method.invoke(
                                        obj, resultSet.getDate(beanPropertyCount));
                            }
                            
                        } catch (SecurityException e) {
                            e.printStackTrace();
                        } catch (NoSuchMethodException e) {
                            //e.printStackTrace();
                            logger.warning("No such method: " + methodName);
                        } catch (IllegalArgumentException e) {
                            e.printStackTrace();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        } catch (InvocationTargetException e) {
                            e.printStackTrace();
                        }
                        
                    }
                    
                } catch (InstantiationException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
                
                // Save datamodelBeans array
                datamodelBeans.add((DatamodelTransferObject) obj);
//                tmpDatamodelBeans = new DatamodelBean[datamodelBeans.length];
//                System.arraycopy(datamodelBeans, 0,
//                        tmpDatamodelBeans, 0,
//                        datamodelBeans.length);
//                // Create new array with one additional slot
//                datamodelBeans = new DatamodelBean[datamodelBeans.length + 1];
//                // Copy array back
//                System.arraycopy(tmpDatamodelBeans, 0,
//                        datamodelBeans, 0,
//                        tmpDatamodelBeans.length);
//                // Put bean into array
//                datamodelBeans[datamodelBeans.length - 1] = (DatamodelBean) obj;
                
                // Increase row counter
                rowCount++;
                
            }
            
        } catch (SQLException e) {
            throw new DatamodelException("", e);
        }
        
        return datamodelBeans.toArray(new DatamodelTransferObject[datamodelBeans.size()]);
        
    }
    
    /**
     *
     * @param args
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        
        long start = 0l;
        long stop = 0l;
        Connection c = null;
        OracleDatamodel gdm = null;
        Document d = null;
        
        Class.forName("oracle.jdbc.OracleDriver");
        c = DriverManager.getConnection(
                "jdbc:oracle:thin:@192.168.100.15:1521:TIM", "tim", "tim");
        
        start = System.currentTimeMillis();
        gdm = OracleDatamodel.getInstance(c);
        stop = System.currentTimeMillis();
        System.out.println("duration=" + ((stop - start) / 1000.0d));
        
        d = gdm.getDatamodelDocument();
        
        // Output XML document
        JAXPOutput.output(d, System.out);
        
//        Element table = gdm.getTableOrViewElement("MITARBEITER");
//        System.out.println("getTableOrViewElement: "
//                + table.getChildNodes().getLength());
//        for (String s : gdm.getColumnNames("MITARBEITER")) {
//            System.out.println("" + s);
//        }
        
//        Element procedure = gdm.getProcedureOrFunctionElement(
//                "TIM_USER", "MITARBEITER_HINZU");
//        System.out.println("getProcedureOrFunctionElement: " +
//                procedure.getChildNodes().getLength());
//        for (String s : gdm.getArgumentNames("TIM_USER", "MITARBEITER_HINZU")) {
//            System.out.println("" + s);
//        }
        
//        PreparedStatement pstmt = gdm.getPreparedSelectStatement(
//                "V_MITARBEITER",
//                new String[] { "MITARBEITERID", "NACHNAME" },
//                "MITARBEITERID = ?");
//        pstmt.setInt(1, 1);
//        ResultSet rs = pstmt.executeQuery();
//        while (rs.next()) {
//            System.out.println(
//                    rs.getString("MITARBEITERID") +
//                    " " +
//                    rs.getString("NACHNAME"));
//        }
        
//        PreparedStatement pstmt2 = gdm.getPreparedInsertStatement(
//                "MITARBEITER");
//
//        System.out.println("" + gdm.getColumnType("MITARBEITER", "ID"));
//
//        start = System.currentTimeMillis();
//        gdm = OracleDatamodel.getInstance(c);
//        stop = System.currentTimeMillis();
//        System.out.println("duration=" + ((stop-start)/1000.0d));
        
//        d = gdm.getDocument();
        
//        System.out.println("V_MITARBEITER.EMAIL=" +
//                gdm.columnExists("V_MITARBEITER", "EMAIL"));
        
//        // Test bean with procedure
//        TestBean t = new TestBean();
//        t.anschriftprivat="meine anschrift 12";
//        t.ansprechpartner="Caroline2 Bensmann";
//        t.email="caroline@bensmann.de";
//        t.endzeit = new java.util.Date();
//        t.startzeit = new java.util.Date();
//        t.erstelltMitarbeiterId = 1;
//        t.fax = "2";
//        t.telefon = "3";
//        t.geburtsdatum = new java.util.Date();
//        t.jahresurlaubTage=30;
//        t.sollstundenMonat=160;
//        t.nachname="Bensmann";
//        t.vorname="Caroline2";
//        t.plzprivat="48351";
//        t.ortprivat="Blabla";
//        t.niederlassungid=1;
//        gdm.beanToProcedure(t, "TIM_USER", "MITARBEITER_HINZU");
//        System.out.println("ID="+t.id);
        
        MyBean myBean = new MyBean();
        myBean.setVorname("%a%");
        myBean.setMitarbeiterid(1);
//        Calendar cal = Calendar.getInstance();
//        cal.set(Calendar.YEAR, 1978);
//        cal.set(Calendar.MONTH, 9 - 1);
//        cal.set(Calendar.DAY_OF_MONTH, 20);
//        myBean.setGeburtsdatum(cal.getTime());
        DatamodelTransferObject[] beans =
                gdm.selectIntoTransferObject("V_MITARBEITER", myBean, null);
        System.out.println("Found " + beans.length + " entries.");
        for (DatamodelTransferObject b : beans) {
            if (b != null) {
                System.out.println("id: " +
                        ((MyBean) b).getMitarbeiterid());
                System.out.println("vorname: " +
                        ((MyBean) b).getVorname());
                System.out.println("nachname: " +
                        ((MyBean) b).getNachname());
                System.out.println("geburtsdatum: " +
                        ((MyBean) b).getGeburtsdatum());
                System.out.println("\n\n");
            }
        }
        
    }
    
}
